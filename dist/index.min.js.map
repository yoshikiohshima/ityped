{"version":3,"file":"index.min.js","sources":["../src/index.js"],"sourcesContent":["/**\n * @name setProps\n * @description Set the ityped properties configuration\n * @param {Object} config The configuration properties\n * @return {Promise}\n */\nconst setProps = ({\n  typeSpeed = 100,\n  backSpeed = 50,\n  backDelay = 500,\n  startDelay = 500,\n  cursorChar = '|',\n  showCursor = true,\n  disableBackTyping = false,\n  onFinished = function () { },\n  loop = true\n}) => ({\n  typeSpeed,\n  backSpeed,\n  cursorChar,\n  backDelay,\n  startDelay,\n  showCursor,\n  loop,\n  disableBackTyping,\n  onFinished\n})\n\nexport const init = (element, properties) => {\n    let i = 0, l, WORK_TO_DO;\n    let state = {}; // {id: {pos: number}}\n    let text = \"\";\n    \n    const typewrite = (work, props) => {\n        if (i === 1)\n            if (props.loop) i = 0;\n        setTimeout(() => { typeString(work, props); }, props.startDelay);\n    }\n\n    const typeString = (work, props) => {\n        let index = 0;\n        let workLen = work.length;\n        let intervalID = setInterval(() => {\n            doWork(work[index++], props);\n            if (index === workLen) {\n                onStringTyped(intervalID, props);\n            }\n        }, props.typeSpeed);\n    }\n\n    const makeSpans = () => {\n        let result = [];\n        for (let i = 0; i < text.length; i++) {\n            let span = document.createElement(\"span\");\n            span.textContent = text[i];\n            result.push(span);\n        }\n        return result;\n    }\n\n    const doWork = (workArray, props) => {\n        workArray.forEach(work => {\n            let id = `${work.id}`;\n            if (!state[id]) {\n                state[id] = {pos: 0};\n            }\n\n            if (work.append !== undefined) {\n                let before = text.slice(0, state[id].pos);\n                let after = text.slice(state[id].pos);\n                text = before + work.append + after;\n                state[id].pos++;\n                Object.keys(state).forEach(key => {\n                    if (key === id) {return;}\n                    if (state[key].pos >= state[id].pos)\n                        state[key].pos++;\n                });\n            }\n            if (work.goto !== undefined) {\n                state[id].pos = work.goto;\n            }\n            if (work.backspace !== undefined) {\n                let before = text.slice(0, state[id].pos - 1);\n                let after = text.slice(state[id].pos);\n                text = before + after;\n                state[id].pos--;\n                Object.keys(state).forEach(key => {\n                    if (key === id) {return;}\n                    if (state[key].pos >= state[id].pos)\n                        state[key].pos--;\n                });\n                \n            }\n        });\n        while (element.lastChild) {\n            element.lastChild.remove();\n        }\n        makeSpans().forEach(s => \n            element.appendChild(s)\n        )\n        positionCursors();\n    }\n \n    const onStringTyped = (id, props) => {\n        clearInterval(id);\n        if (props.disableBackTyping) {\n            return props.onFinished()\n        }\n        if (!props.loop) {\n            return props.onFinished();\n        }\n        setTimeout(() => eraseString(props), props.backDelay);\n    }\n\n    const eraseString = (props) => {\n        let w = [{id: 0, backspace: 1}]\n        let intervalID = setInterval(() => {\n            doWork(w, props);\n            if (text.length === 0) return onStringErased(intervalID, props);\n        }, props.backSpeed);\n    }\n\n    const clearState = () => {\n        Object.keys(state).forEach(key => {\n            let s = state[key];\n            if (s.cursor) {\n                s.cursor.remove();\n                s.cursor = null;\n            }\n        });\n        state = {};\n        text = \"\";\n    }\n\n    const onStringErased = (id, props) => {\n        clearInterval(id);\n        ++i;\n        clearState();\n        typewrite(WORK_TO_DO, props);\n    }\n\n    const positionCursors = () => {\n        let eRect = element.parentNode.getBoundingClientRect();\n        Object.keys(state).forEach(key => {\n            let s = state[key];\n            if (!s.cursor) {\n                s.cursor = document.createElement('span');\n                s.cursor.classList.add('ityped-cursor');\n                s.cursor.classList.add(`ityped-cursor-${key}`);\n                s.cursor.textContent = \"|\";\n                s.cursor.width = \"0\";\n                s.cursor.style.position = \"relative\";\n                s.cursor.style.fontWeight = 800;\n                let cursors = document.querySelector(\"#ityped-cursors\");\n                cursors.appendChild(s.cursor);\n            }\n            let span = s.pos === 0 ? null : element.childNodes[s.pos - 1];\n            let rect = span ? span.getBoundingClientRect() : {right: 0}\n            let cRect = s.cursor.getBoundingClientRect();\n            let keyNum = parseFloat(key);\n            s.cursor.style.left = `${rect.right - (cRect.width * 0.5) - (keyNum * cRect.width) - eRect.left}px`;\n            s.cursor.style.top = `${rect.top - eRect.top}px`;\n            s.cursor.style.height = `${eRect.height}px`;\n        })\n    }\n        \n    const startTyping = (prop) => {\n        let props = setProps(prop || {})\n        let work = prop.work\n\n        WORK_TO_DO = work;\n        if (typeof element === \"string\") element = document.querySelector(element)\n        // if (props.showCursor) setCursor(element, props)\n        typewrite(WORK_TO_DO, props)\n    }\n    return startTyping(properties)\n}\n\n// window.ityped = {init};\n"],"names":["element","properties","i","WORK_TO_DO","state","text","typewrite","work","props","loop","startDelay","typeString","index","workLen","length","intervalID","setInterval","typeSpeed","doWork","workArray","forEach","id","pos","undefined","append","before","slice","after","keys","key","goto","backspace","lastChild","remove","result","span","document","createElement","textContent","push","appendChild","s","onStringTyped","disableBackTyping","onFinished","eraseString","backDelay","w","onStringErased","backSpeed","cursor","positionCursors","eRect","parentNode","getBoundingClientRect","classList","add","width","style","position","fontWeight","querySelector","childNodes","rect","right","cRect","keyNum","parseFloat","left","top","height","prop","cursorChar","showCursor","setProps","startTyping"],"mappings":"gMA4BoB,SAACA,EAASC,OACtBC,EAAI,EAAMC,SACVC,KACAC,EAAO,GAELC,EAAY,SAACC,EAAMC,GACX,IAANN,GACIM,EAAMC,OAAMP,EAAI,cACb,aAAmBK,EAAMC,IAAWA,EAAME,aAGnDC,EAAa,SAACJ,EAAMC,OAClBI,EAAQ,EACRC,EAAUN,EAAKO,OACfC,EAAaC,YAAY,aAClBT,EAAKK,KAAUJ,GAClBI,IAAUC,KACIE,EAAYP,IAE/BA,EAAMS,YAaPC,EAAS,SAACC,EAAWX,SACbY,QAAQ,gBACVC,KAAQd,EAAKc,MACZjB,EAAMiB,OACDA,IAAOC,IAAK,SAGFC,IAAhBhB,EAAKiB,OAAsB,KACvBC,EAASpB,EAAKqB,MAAM,EAAGtB,EAAMiB,GAAIC,KACjCK,EAAQtB,EAAKqB,MAAMtB,EAAMiB,GAAIC,OAC1BG,EAASlB,EAAKiB,OAASG,IACxBN,GAAIC,aACHM,KAAKxB,GAAOgB,QAAQ,YACnBS,IAAQR,GACRjB,EAAMyB,GAAKP,KAAOlB,EAAMiB,GAAIC,KAC5BlB,EAAMyB,GAAKP,gBAGLC,IAAdhB,EAAKuB,SACCT,GAAIC,IAAMf,EAAKuB,WAEFP,IAAnBhB,EAAKwB,UAAyB,KAC1BN,EAASpB,EAAKqB,MAAM,EAAGtB,EAAMiB,GAAIC,IAAM,GACvCK,EAAQtB,EAAKqB,MAAMtB,EAAMiB,GAAIC,OAC1BG,EAASE,IACVN,GAAIC,aACHM,KAAKxB,GAAOgB,QAAQ,YACnBS,IAAQR,GACRjB,EAAMyB,GAAKP,KAAOlB,EAAMiB,GAAIC,KAC5BlB,EAAMyB,GAAKP,WAKpBtB,EAAQgC,aACHA,UAAUC,UA7CR,eAET,IADDC,KACKhC,EAAI,EAAGA,EAAIG,EAAKS,OAAQZ,IAAK,KAC9BiC,EAAOC,SAASC,cAAc,UAC7BC,YAAcjC,EAAKH,KACjBqC,KAAKJ,UAETD,MAwCKd,QAAQ,mBAChBpB,EAAQwC,YAAYC,UAKtBC,EAAgB,SAACrB,EAAIb,wBACTa,GACVb,EAAMmC,kBACCnC,EAAMoC,aAEZpC,EAAMC,qBAGA,kBAAMoC,EAAYrC,IAAQA,EAAMsC,WAFhCtC,EAAMoC,cAKfC,EAAc,SAACrC,OACbuC,IAAM1B,GAAI,EAAGU,UAAW,IACxBhB,EAAaC,YAAY,gBAClB+B,EAAGvC,GACU,IAAhBH,EAAKS,OAAc,OAAOkC,EAAejC,EAAYP,IAC1DA,EAAMyC,YAePD,EAAiB,SAAC3B,EAAIb,iBACVa,KACZnB,SAbK0B,KAAKxB,GAAOgB,QAAQ,gBACnBqB,EAAIrC,EAAMyB,GACVY,EAAES,WACAA,OAAOjB,WACPiB,OAAS,eAIZ,KAOG/C,EAAYK,IAGpB2C,EAAkB,eAChBC,EAAQpD,EAAQqD,WAAWC,+BACxB1B,KAAKxB,GAAOgB,QAAQ,gBACnBqB,EAAIrC,EAAMyB,GACTY,EAAES,WACDA,OAASd,SAASC,cAAc,UAChCa,OAAOK,UAAUC,IAAI,mBACrBN,OAAOK,UAAUC,qBAAqB3B,KACtCqB,OAAOZ,YAAc,MACrBY,OAAOO,MAAQ,MACfP,OAAOQ,MAAMC,SAAW,aACxBT,OAAOQ,MAAME,WAAa,IACdxB,SAASyB,cAAc,mBAC7BrB,YAAYC,EAAES,aAEtBf,EAAiB,IAAVM,EAAEnB,IAAY,KAAOtB,EAAQ8D,WAAWrB,EAAEnB,IAAM,GACvDyC,EAAO5B,EAAOA,EAAKmB,yBAA2BU,MAAO,GACrDC,EAAQxB,EAAES,OAAOI,wBACjBY,EAASC,WAAWtC,KACtBqB,OAAOQ,MAAMU,KAAUL,EAAKC,MAAuB,GAAdC,EAAMR,MAAgBS,EAASD,EAAMR,MAASL,EAAMgB,YACzFlB,OAAOQ,MAAMW,IAASN,EAAKM,IAAMjB,EAAMiB,WACvCnB,OAAOQ,MAAMY,OAAYlB,EAAMkB,sBAIrB,SAACC,OACb/D,EAjKK,oBACfS,UAAAA,aAAY,UACZgC,UAAAA,aAAY,SACZH,UAAAA,aAAY,UACZpC,WAAAA,aAAa,UACb8D,WAAAA,aAAa,UACbC,WAAAA,oBACA9B,kBAAAA,oBACAC,WAAAA,aAAa,mBACbnC,4IAwJkBiE,CAASH,OACjBhE,EAAOgE,EAAKhE,OAEHA,EACU,iBAAZP,IAAsBA,EAAUoC,SAASyB,cAAc7D,MAExDG,EAAYK,GAEnBmE,CAAY1E"}